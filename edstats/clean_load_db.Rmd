---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

---

```{r}
# packages
library('RPostgreSQL')
```



```{r}
create_eddetails_table_db = function() {
  
  # read just few rows to get column details
  tempdf = read.csv(file="/Users/gauravbishnoi/datas/Edstats_csv/EdStatsData.csv", nrows = 10)
  # change first 4 columns from factor to just characters
  tempdf[,c(1,2,3,4)] = apply(tempdf[,c(1,2,3,4)], 2, function(x) as.character(x))
  # drop columns from year 2015 onwards because they are empty
  tempdf[,grep('X2015', colnames(tempdf)):length(colnames(tempdf))] = NULL
  # drop column 'Indicator.Name'
  tempdf[,'Indicator.Name'] = NULL
  # delete rows with at least 30 missing values
  tempdf = tempdf[rowSums(is.na(tempdf)) <= 30, ]
  # modify column names to avoid period and large cap
  colnames(tempdf) = sapply(colnames(tempdf), function(x) tolower(gsub("\\.", "_", x)), USE.NAMES = FALSE)
  
  # make sql stament to create table in db with colnames columns

  # col names with types
  col_names = colnames(tempdf)
  
  # string for modified column names and data types. To be used in command to create table.
  sql_col_name_type = ""
  for(name in col_names) {
    
    if (class(tempdf[,name]) == 'character') {
      sql_col_name_type = paste(sql_col_name_type, " ", name, " ", class(tempdf[,name]), " varying,", "\n", sep="")
    }
    else {
      sql_col_name_type = paste(sql_col_name_type, " ", name, " ", class(tempdf[,name]), ",", "\n", sep="")
    }
    
  }
  # removing comma and newline after last column name and data type.
  sql_col_name_type = substr(sql_col_name_type, 1, nchar(sql_col_name_type)-2) 
  
  # command to create table
  create_command = paste("CREATE TABLE IF NOT EXISTS ", "eddetails", "\n(\n", sql_col_name_type, "\n)\nWITH (\nOIDS = FALSE\n);\n", sep="")
  
  #command to change ownership of table
  alter_command = "ALTER TABLE eddetails OWNER TO postgres;"
  
  # complete command to create table and change ownership
  create_table_command = paste(create_command, alter_command, sep="")
  
  # connect to database
  con = connect_db()
  # execute command 
  dbGetQuery(con, create_table_command)
  # close connection to database
  dbDisconnect(con)
}

```

```{r}
connect_db = function() {
  # Connect to data base
  pg = dbDriver("PostgreSQL")
  con = dbConnect(pg, user="postgres", password="password", host="localhost", port=5432, dbname="edstatsdb")
  return (con)
}
```


```{r}
create_eddetails_table_db()
```


```{r}
fill_db = function() {
  
  con = connect_db() # connection to database
  chunk_size = 25573 # number of lines to be read at a time from csv file
  
  csv_con = file("/Users/gauravbishnoi/datas/Edstats_csv/EdStatsData.csv", "r") # connection to csv file
  
  # get column names from sql db table
  column_names = dbGetQuery(con, "SELECT column_name FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'eddetails';")
  
  column_line = read.csv(csv_con, nrows = 1, header = FALSE) # row with column details, now the file will be read from second row
  
  i = 0
  
  while (TRUE) {
    
    # read chunk_size lines from csv and store in temp database
    dff = read.csv(file = csv_con, nrows = chunk_size, header = FALSE)
    # save length of rows for later comparison
    dff_lines_original = NROW(dff)
    # change data type of first 4 rows from factor to character
    dff[,c(1,2,3,4)] = apply(dff[,c(1,2,3,4)], 2, function(x) as.character(x))
    # drop columns from year 2015 onwards because they are empty
    dff[,50:length(colnames(dff))] = NULL
    # drop column 'Indicator.Name'
    dff[,3] = NULL
    # drop rows that still contain at least 30 missing values
    dff = dff[rowSums(is.na(dff)) <= 30, ]
    
    
    # assign those names to current data frame
    colnames(dff) = column_names[, 1]
    
    i = i + 1
    print(i)
    
    # write current data frame into sql db table
    dbWriteTable(con, "eddetails", value = dff, append = TRUE, row.names = FALSE)
    
    # delete dff for this iteration
    rm(dff)
    
    # if total read lines from csv were less than chunk_size, reading is finished
    if (dff_lines_original < chunk_size) {
      break
    }
    
  }
  
  # close connection to csv file
  close(csv_con)
    
  # close connection to database
  dbDisconnect(con)
  
}
```

```{r}
fill_db()
```




```{r}
conn = connect_db()
```

```{r}
dff = read.csv(file="/Users/gauravbishnoi/datas/Edstats_csv/EdStatsData.csv", nrows = 10, skip = 1, header = FALSE)
dff[,c(1,2,3,4)] = apply(dff[,c(1,2,3,4)], 2, function(x) as.character(x))
dff[,50:length(colnames(dff))] = NULL
dff[,3] = NULL
dff = dff[rowSums(is.na(dff)) <= 30, ]

xy = dbGetQuery(conn, "SELECT column_name FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'eddetails';")
colnames(dff) = xy[, 1]

```

```{r}
dbWriteTable(conn, "eddetails", value = dff, append = TRUE, row.names = FALSE)
```
```{r}
# dbGetQuery(conn, "DELETE FROM eddetails;")
```

```{r}
dbDisconnect(conn)
```







Read first 10 lines of EdStatsData.csv
```{r}
checkcsv = read.csv(file="/Users/gauravbishnoi/datas/Edstats_csv/EdStatsData.csv", nrows = 10)
checkcsv
```

```{r}
# change class of first 4 columns from factor to character
chcol = c(1,2,3,4)
checkcsv[,chcol] = apply(checkcsv[,chcol], 2, function(x) as.character(x))
```

```{r}
# drop columns from year 2015 onwards because they are empty
checkcsv[,grep('X2015', colnames(checkcsv)):length(colnames(checkcsv))] = NULL
```

```{r}
checkcsv[,'Indicator.Name'] = NULL
```

```{r}
# delete rows with at least 30 missing values
checkcsv = checkcsv[rowSums(is.na(checkcsv)) <= 30, ]
```

```{r}
# modify column names to avoid period and large cap
colnames(checkcsv) = sapply(colnames(checkcsv), function(x) tolower(gsub("\\.", "_", x)), USE.NAMES = FALSE)
```

```{r}
# make sql stament to create table in db with colnames columns

# col names with types
col_names = colnames(checkcsv)
#class(checkcsv[,col_names[5]])
sql_col_name_type = ""
for(name in col_names) {
  sql_col_name_type = paste(sql_col_name_type, " ", name, " ", class(checkcsv[,name]), ",", "\n", sep="")
}
sql_col_name_type = substr(sql_col_name_type, 1, nchar(sql_col_name_type)-2)

create_command = paste("CREATE TABLE IF NOT EXISTS ", "eddetails", "\n(\n", sql_col_name_type, "\n)\nWITH (\nOIDS = FALSE\n);\n", sep="")

alter_command = "ALTER TABLE eddetails OWNER TO postgres;"

create_table_command = paste(create_command, alter_command, sep="")

cat(create_table_command)
```

```{r}
library('RPostgreSQL')
pg = dbDriver("PostgreSQL")
con = dbConnect(pg, user="postgres", password="password", host="localhost", port=5432, dbname="edstatsdb")
```

```{r}
dbGetQuery(con, create_table_command)
```

```{r}
# open connection to csv file
csv_con = file("/Users/gauravbishnoi/datas/Edstats_csv/EdStatsData.csv", "r")
```

```{r}
# read column name line, then the tracker will be on line 2
read.csv(csv_con, nrows=1, header = FALSE)
```
```{r}

```



```{r}
close(csv_con)
```

```{r}
conn = file("/Users/gauravbishnoi/Desktop/trys.csv", "r")
```

```{r}
read.csv(conn, nrows = 1, header = TRUE)
```


```{r}
while (TRUE) {
  dfi = read.csv(conn, nrows=4, header = FALSE)
  print(dfi)
  if (NROW(dfi) < 4) {
    break
  }
}

#read.csv(conn, nrows=4, header = FALSE)
```

```{r}
close(conn)
```

```{r}
rm(list=ls())
```








```{r}
dbDisconnect(con)
```

